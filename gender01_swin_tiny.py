# -*- coding: utf-8 -*-
"""Gender01_Swin_Tiny

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1uQ1ICMxiEx1tcS1SRleqCzZaoEbsH7tc
"""

import torch
import torch.nn as nn
import torch.optim as optim
import torchvision.models as models
from torch.utils.data import DataLoader
from torchvision.datasets import ImageFolder
from torchvision.transforms import transforms
from google.colab import drive
from sklearn.metrics import roc_auc_score
import numpy as np
from timm.models import swin_tiny_patch4_window7_224  # import Swin Tiny

device = torch.device("cuda" if torch.cuda.is_available() else "cpu")

# Mount Google Drive
drive.mount('/content/drive')

# Define data transforms
transform = transforms.Compose([
    transforms.Resize((224, 224)),
    transforms.ToTensor(),
    transforms.Normalize([0.5], [0.5])
])

# Load training data
train_data = ImageFolder(root='/content/drive/My Drive/Liang/Gender01/train', transform=transform)
train_loader = DataLoader(train_data, batch_size=64, shuffle=True)

# Load test data
test_data = ImageFolder(root='/content/drive/My Drive/Liang/Gender01/test', transform=transform)
test_loader = DataLoader(test_data, batch_size=64, shuffle=False)

# Define the model
model = swin_tiny_patch4_window7_224(pretrained=True, num_classes=2)
model.to(device)

# Define the loss function and optimizer
criterion = nn.CrossEntropyLoss()
optimizer = optim.Adam(model.parameters(), lr=0.001)

# Train the model
num_epochs = 10
for epoch in range(num_epochs):
    train_loss = 0
    train_correct = 0
    model.train()

    for inputs, labels in train_loader:
        inputs, labels = inputs.to(device), labels.to(device)
        optimizer.zero_grad()
        outputs = model(inputs)
        loss = criterion(outputs, labels)
        loss.backward()
        optimizer.step()
        train_loss += loss.item() * inputs.size(0)
        _, preds = torch.max(outputs, 1)
        train_correct += torch.sum(preds == labels.data)

    train_loss = train_loss / len(train_data)
    train_acc = train_correct.double() / len(train_data)

    print(f"Epoch {epoch+1}/{num_epochs}, Train Loss: {train_loss:.4f}, Train Acc: {train_acc:.4f}")

# Test the model

test_loss = 0
test_correct = 0
model.eval()

with torch.no_grad():
    for inputs, labels in test_loader:
        inputs, labels = inputs.to(device), labels.to(device)
        outputs = model(inputs)
        loss = criterion(outputs, labels)
        test_loss += loss.item() * inputs.size(0)
        _, preds = torch.max(outputs, 1)
        test_correct += torch.sum(preds == labels.data)

test_loss = test_loss / len(test_data)
test_acc = test_correct.double() / len(test_data)

print(f"Test Loss: {test_loss:.4f}, Test Acc: {test_acc:.4f}")

# Update the weights
torch.save(model.state_dict(), 'swin_tiny_directions.pt')

#Calculate Performance metrics
from sklearn.metrics import roc_auc_score
import numpy as np

test_loss = 0
test_correct = 0
y_true = []
y_scores = []

model.eval()

with torch.no_grad():
    for inputs, labels in test_loader:
        inputs, labels = inputs.to(device), labels.to(device)
        outputs = model(inputs)
        loss = criterion(outputs, labels)
        test_loss += loss.item() * inputs.size(0)
        _, preds = torch.max(outputs, 1)
        test_correct += torch.sum(preds == labels.data)

        # Convert labels to one-hot encoding
        labels_onehot = torch.zeros(labels.size(0), 4).to(device)
        labels_onehot.scatter_(1, labels.view(-1,1), 1)
        y_true.append(labels_onehot.cpu().numpy())

        # Softmax outputs and extract probabilities for each class
        outputs = nn.functional.softmax(outputs, dim=1)
        y_scores.append(outputs.cpu().numpy())

test_loss = test_loss / len(test_data)
test_acc = test_correct.double() / len(test_data)

y_true = np.concatenate(y_true)
y_scores = np.concatenate(y_scores)

# Calculate AUCs for each class
auc_male = roc_auc_score(y_true[:, 0], y_scores[:, 0])
auc_female = roc_auc_score(y_true[:, 1], y_scores[:, 1])

# Calculate mean AUC
mean_auc = (auc_male + auc_female) / 2

print(f"Test Loss: {test_loss:.4f}, Test Acc: {test_acc:.4f}")
print(f"AUC (Male): {auc_male:.4f}")
print(f"AUC (Female): {auc_female:.4f}")
print(f"Mean AUC: {mean_auc:.4f}")


test_correct = 0
model.eval()

with torch.no_grad():
    for inputs, labels in test_loader:
        inputs, labels = inputs.to(device), labels.to(device)
        outputs = model(inputs)
        _, preds = torch.max(outputs, 1)
        test_correct += torch.sum(preds == labels.data)

test_acc = test_correct.double() / len(test_data) * 100
print(f"Test Accuracy: {test_acc:.2f}%")